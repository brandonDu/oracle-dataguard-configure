# Oracle dataguard 快速配置(脚本篇)

```markdown
主库：
ip: 192.168.0.2
db_name: orcl
db_unique_name: primary
备机：
ip: 192.168.0.3
db_name: orcl
db_unique_name: standby
```

1. 主库安装*oracle*和*database*
2. 备库仅仅安装*oracle*软件，不创建*database*
3. 备库执行*create_instance_orcl.bat*  `创建实例并创建目录结构`

### 主库设置

1. 查看主库安装信息，执行脚本`pri_check_info_primary.bat`。 调用`pri_check_info_primary.sql`
2. 创建密码文件，执行脚本`pri_orapwd.bat`。 (**总是出现循环错误，建议打开文件，手动执行里面的命令行**)
3. 启动强制归档并查看联机日志信息，执行脚本`pri_enable_logging_redo.bat`。调用`pri_enable_logging_redo.sql`
4. 根据查询信息，调整`pri_con_stdby_redo.sql` 中的联机日志编号， 调用`pri_con_stdby_redo.bat`
5. 设置主库归档模式，执行脚本`pri_enable_archiving.bat`。 调用`pri_enable_archiving.sql`
6. 设置主库初始化参数。调用脚本创建目录以及创建pfile文件。执行脚本`pri_create_archive_dir.bat`。调用`pri_create_primary_pfile.sql`
7. 在pfile文件结尾添加一下内容，如有调整，适量修改`C:\oracle\pfileorcl.ora`。

```ora
db_name='orcl'
db_unique_name='primary'
LOG_ARCHIVE_CONFIG='DG_CONFIG=(primary,standby)'
LOG_ARCHIVE_DEST_1= 'LOCATION=C:\oracle\archive VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=primary'
LOG_ARCHIVE_DEST_2= 'SERVICE=standby LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=standby'
LOG_ARCHIVE_DEST_STATE_1=ENABLE
LOG_ARCHIVE_DEST_STATE_2=ENABLE
REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE
LOG_ARCHIVE_FORMAT=log_%t_%s_%r.arc
LOG_ARCHIVE_MAX_PROCESSES=30

fal_server=standby
fal_client=primary
standby_file_management=auto
db_file_name_convert='standby','primary'
log_file_name_convert='C:\oracle\product\10.2.0\oradata\orcl','C:\oracle\product\10.2.0\oradata\orcl'
```

8. 根据pfile创建spfile文件，并restart oracle，执行脚本`pri_pfile_to_spfile_restart.bat`。调用`pri_pfile_to_spfile_restart.sql`
9. 为备库创建控制文件，执行脚本`pri_create_control_file.bat`。调用`pri_create_control_file.sql`。
10. 配置C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN下的listener.ora和tsname.ora文件。

**Listener.ora**

```
# listener.ora Network Configuration File: C:\oracle\product\10.2.0\db_1\network\admin\listener.ora
# Generated by Oracle configuration tools.

SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (SID_NAME = PLSExtProc)
      (ORACLE_HOME = C:\oracle\product\10.2.0\db_1)
      (PROGRAM = extproc)
    )
    (SID_DESC =
      (SID_NAME = orcl)
      (ORACLE_HOME = C:\oracle\product\10.2.0\db_1)
      (PROGRAM = orcl)
    )
  )

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))
      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.2)(PORT = 1521))
    )
  )

```

**Tsname.ora**

```
# tnsnames.ora Network Configuration File: C:\oracle\product\10.2.0\db_1\network\admin\tnsnames.ora
# Generated by Oracle configuration tools.

primary =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.2)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = primary)
    )
  )
standby =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.3)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = standby)
    )
  )

EXTPROC_CONNECTION_DATA =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))
    )
    (CONNECT_DATA =
      (SID = PLSExtProc)
      (PRESENTATION = RO)
    )
  )
```

---

**此处涉及拷贝，请先shutdown主库oracle**

* 将主库的数据文件，控制文件，密码文件，以及pfile拷贝到备机相应目录下。
* 控制文件复制三个，修改名字为：CONTROL01.CTL，CONTROL02.CTL，CONTROL03.CTL， 并保存早C:\oracle\product\10.2.0\oradata\orcl下。保存数据文件到C:\oracle\product\10.2.0\oradata\orcl下。
* 保存密码文件到C:\oracle\product\10.2.0\db_1\database下。
* 创建路径：C:\oracle\archive

---

### 备机操作

1. 配置参数文件，修改pfile文件内容。

```
db_name='orcl'
db_unique_name='standby'
LOG_ARCHIVE_CONFIG='DG_CONFIG=(primary,standby)'
LOG_ARCHIVE_DEST_1= 'LOCATION=C:\oracle\archive VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=standby'
LOG_ARCHIVE_DEST_2= 'SERVICE=primary LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=primary'
LOG_ARCHIVE_DEST_STATE_1=ENABLE
LOG_ARCHIVE_DEST_STATE_2=ENABLE
REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE
LOG_ARCHIVE_FORMAT=log_%t_%s_%r.arc
LOG_ARCHIVE_MAX_PROCESSES=30

fal_server=primary
fal_client=standby
standby_file_management=auto
db_file_name_convert='primary','standby'
log_file_name_convert='c:\oracle\product\10.2.0\oradata\orcl','c:\oracle\product\10.2.0\oradata\orcl'
```

2. 配置C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN下的listener.ora和tsname.ora文件。

**Listener.ora**

```
# listener.ora Network Configuration File: C:\oracle\product\10.2.0\db_1\network\admin\listener.ora
# Generated by Oracle configuration tools.

SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (SID_NAME = PLSExtProc)
      (ORACLE_HOME = C:\oracle\product\10.2.0\db_1)
      (PROGRAM = extproc)
    )
    (SID_DESC =
      (SID_NAME = orcl)
      (ORACLE_HOME = C:\oracle\product\10.2.0\db_1)
      (PROGRAM = orcl)
    )
  )

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))
      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.3)(PORT = 1521))
    )
  )
```

**Tsname.ora**

```
# tnsnames.ora Network Configuration File: C:\oracle\product\10.2.0\db_1\network\admin\tnsnames.ora
# Generated by Oracle configuration tools.

primary =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.2)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = primary)
    )
  )
standby =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.3)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = standby)
    )
  )

EXTPROC_CONNECTION_DATA =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))
    )
    (CONNECT_DATA =
      (SID = PLSExtProc)
      (PRESENTATION = RO)
    )
  )
```

3. 生成spfile文件，执行脚本`std_create_spfile.bat`。调用`std_spfile_from_pfile.sql`
4. 挂载数据库。

```plsql
备库执行：SQL> startup mount;
主库执行：SQL> alter system switch logfile;
```

5. 备库添加redo日志。执行脚本`std_cre_redo_log.bat`， 调用`std_add_redo_log.sql`
6. 主库执行测试脚本`create_table_insert_random.bat`，调用`fun_random_test.sql`
7. 备库执行sql查询

```plsql
SELECT SEQUENCE#, FIRST_TIME, NEXT_TIME FROM V$ARCHIVED_LOG ORDER BY SEQUENCE#;
```

8. 查询备库数据是否插入，执行脚本`std_check_insert.bat` ， 调用`std_open_see.sql`


### 备机重启后操作

1. 调用`std_restart_index.bat`, 执行`std_mount_disconnect.sql`

### 一些操作

```plsql
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE NODELAY;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT FROM SESSION;
--查看是否开启实时应用
SELECT  DEST_NAME , STATUS , RECOVERY_MODE FROM V$ARCHIVE_DEST_STATUS;
--开启实时应用
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT FROM SESSION;
-- cancleing a time delay;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE NODELAY;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE;
-- check the archive if applied.
SELECT NAME FROM V$ARCHIVED_LOG WHERE APPLIED='YES' AND NAME IS NOT NULL AND DEST_ID=1; 

```



```basic
--delete_dg_archivelog
cd D:\archivelogdel
d: 
sqlplus / as sysdba @delete_archive.sql 
echo rman target / cmdfile=rman_checkcross.rman>>delete_archivelog.bat 
delete_archivelog.bat >>delete_dg_archivelog_%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%".log 
exit 

--delete_archive.sql 
set lines 150 
col name for a150 
set pagesize 0 feedback off verify off heading off echo off 
spool delete_archivelog.bat 
select 'del '||name from v$archived_log where APPLIED='YES' AND NAME IS NOT NULL and DEST_ID=1; 
spool off 
exit; 

--rman_checkcross.rman 
crosscheck archivelog all; 
delete noprompt expired archivelog all; 
exit 
```



### 创建broker

1. 首先保证*primary, standby*的主备环境，可以采用`alter system switch logfile`在主机和备机看看是否同步。

2. 如果主备环境也就是**Dataguard** 环境完整，则进行**Broker**的环境创建。

3. 在主备均执行SQL语句：

   ```plsql
   Alter system set dg_broker_start=True scope=both;
   ```

4. *primary*执行

```vb
C:\> dgmgrl
```

5.  进入*GDMGRL*命令后，创建*Broker*

```sql
DGMGRL> connect sys/sys@primary
DGMGRL> create configuration 'broker1' as primary database is 'primary' connect identifier is primary; 
-- 'primary' in Connect identifier is the service name through which the broker is connected to the PRIMARY database

DGMGRL> Add database 'standby' as connect identifier is standby maintained as physical;
-- 'standby' in Connect identifier is the service name through which the broker is connected to the STANDBY database

DGMGRL> show configuration;
-- Configuration
-- Name:                  broker1
-- Enabled:               NO
-- Protection Mode:       MaxPerformance
-- Fast-Start Failover:   DISABLE
-- Databases:
--   primary - Physical standby database
--   standby - Primary database
-- Current status for "broker1":
-- DISABLE
DGMGRL> enable configuration;
DGMGRL> show configuration;
-- Name:                  broker1
-- Enabled:               YES
-- Protection Mode:       MaxPerformance
-- Fast-Start Failover:   DISABLE
-- Databases:
--   primary - Physical standby database
--   standby - Primary database
--Current status for "broker1":
--SUCCESS

-- （注意，一定要等待出现success才可以后续执行。）
```



### 开启flashback

1. PRIMARY执行以下命令：

```sql
-- Mount the database, configure flashback retention, start flashback database and open the database.
SQL> SHUTDOWN IMMEDIATE;
SQL> STARTUP MOUNT;
SQL> ALTER SYSTEM SET DB_FLASHBACK_RETENTION_TARGET=1440; 
-- Set up for 24 hour retention 
SQL> ALTER DATABASE FLASHBACK ON;
SQL> ALTER DATABASE OPEN;
-- 可以使用：select flashback_on from v$database; 查看是否开启flashback.
```

2. STANDBY 执行以下命令，*注意先取消redo apply*

```sql
-- Stop redo apply, configure flashback retention, start flashback database, open the database and start redo apply (Is active DG).
SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
SQL> ALTER SYSTEM SET DB_FLASHBACK_RETENTION_TARGET=1440;
SQL> ALTER DATABASE FLASHBACK ON;
SQL> ALTER DATABASE OPEN;
SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT;
-- 可以使用：select flashback_on from v$database; 查看是否开启flashback.
```

3. **注意：等一会哦(Then wait for some time...)**
4. 后边的操作在于检验是否配置成功.

```sql
SQL> select flashback_on from v$database;
c:\dgmgrl
DGMGRL> connect sys/sys@primary;
DGMGRL> show configuration;
--下面的操作只有在测试验证时可以进行，部署生产环境禁止使用。
-- 备机执行
c:\dgmgrl
DGMGRL> connect sys/sys@standby;
DGMGRL> show configuration;
DGMGRL> failover to 'standby'; -- new machine is standby
c:\> sqlplus / as sysdba;
SQL> startup;

-- 你需要等一大会，或者插入一些原来主机没有的东东。

-- if the primary restart, then reconnect the dgmgrl cli.
-- 首先将原来的故障主机，转为备机。
SQL> SHUTDOWN IMMEDIATE;
SQL> STARTUP MOUNT;
SQL> ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
SQL> SELECT DATABASE_ROLE FROM V$DATABASE;
-- PHYSICAL STANDBY
-- 新主机执行，最好重新tnsping一下，同时重新连接一下dgmgrl
C:\> LSNRCTL STOP
C:\> LSNRCTL START
-- 主备均执行一次，切记！
C:\> TNSPING PRIMARY
C:\> TNSPING STANDBY -- 查看primary和standby是否监听都通畅
-- 故障主机进行重启，并进入MOUNT模式
SQL> SHUTDOWN IMMEDIATE;
SQL> STARTUP MOUNT;
-- 新主机执行
SQL> SHUTDOWN IMMEDIATE;
SQL> STARTUP;

c:\dgmgrl
DGMGRL> connect sys/sys@standby;
DGMGRL> reinstate database 'primary'; -- 恢复主机database

-- if succeed! then cogratulation!
-- 重启备机数据库，并使其应用realtime redo apply
-- you succeed! 
-- 备机执行(恢复的故障原主机)
SQL > ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
SQL> ALTER DATABASE OPEN;
SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT;
```







